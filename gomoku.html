<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>五子棋游戏</title>
    <style>
        canvas {
            background-color: #f0d9b5;
            border: 1px solid #333;
        }
        #controls {
            margin-bottom: 10px;
        }
        #controls label, #controls select, #controls button {
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <label for="difficulty">选择难度：</label>
        <select id="difficulty">
            <option value="easy">简单</option>
            <option value="medium">中等</option>
            <option value="hard">困难</option>
        </select>
        <label for="playerColor">选择棋子颜色：</label>
        <select id="playerColor">
            <option value="black">黑棋</option>
            <option value="white">白棋</option>
        </select>
        <button id="startButton">开始游戏</button>
    </div>
    <canvas id="gameCanvas" width="600" height="600"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const size = 10; // 棋盘大小
        const gridSize = canvas.width / size;
        let board = [];
        let currentPlayer = 'black';
        let gameOver = false;
        let aiColor = 'white';
        let playerColor = 'black';
        let difficulty = 'easy';

        document.getElementById('startButton').addEventListener('click', startGame);
        canvas.addEventListener('click', handlePlayerMove);

        function startGame() {
            // 初始化参数
            board = Array(size).fill(null).map(() => Array(size).fill(null));
            currentPlayer = 'black';
            gameOver = false;
            difficulty = document.getElementById('difficulty').value;
            playerColor = document.getElementById('playerColor').value;
            aiColor = playerColor === 'black' ? 'white' : 'black';
            drawBoard();

            // 如果 AI 先手
            if (currentPlayer === aiColor) {
                aiMove();
            }
        }

        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // 绘制棋盘线
            for (let i = 0; i < size; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize + gridSize / 2, gridSize / 2);
                ctx.lineTo(i * gridSize + gridSize / 2, canvas.height - gridSize / 2);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(gridSize / 2, i * gridSize + gridSize / 2);
                ctx.lineTo(canvas.width - gridSize / 2, i * gridSize + gridSize / 2);
                ctx.stroke();
            }

            // 绘制棋子
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    if (board[x][y]) {
                        drawPiece(x, y, board[x][y]);
                    }
                }
            }
        }

        function drawPiece(x, y, color) {
            ctx.beginPath();
            ctx.arc(
                x * gridSize + gridSize / 2,
                y * gridSize + gridSize / 2,
                gridSize / 2 - 2,
                0,
                2 * Math.PI
            );
            ctx.fillStyle = color;
            ctx.fill();
        }

        function handlePlayerMove(event) {
            if (gameOver || currentPlayer !== playerColor) return;

            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((event.clientX - rect.left) / gridSize);
            const y = Math.floor((event.clientY - rect.top) / gridSize);

            if (board[x][y]) return;

            board[x][y] = currentPlayer;
            drawBoard();

            if (checkWin(x, y)) {
                alert(`你赢了！`);
                gameOver = true;
                return;
            }

            if (isBoardFull()) {
                alert('平局！');
                gameOver = true;
                return;
            }

            currentPlayer = aiColor;
            setTimeout(aiMove, 500); // 给 AI 一些思考时间
        }

        function aiMove() {
            if (gameOver) return;

            let move;
            switch (difficulty) {
                case 'easy':
                    move = getRandomMove();
                    break;
                case 'medium':
                    move = getMediumMove();
                    break;
                case 'hard':
                    move = getBestMove();
                    break;
            }

            board[move.x][move.y] = currentPlayer;
            drawBoard();

            if (checkWin(move.x, move.y)) {
                alert(`AI 赢了！`);
                gameOver = true;
                return;
            }

            if (isBoardFull()) {
                alert('平局！');
                gameOver = true;
                return;
            }

            currentPlayer = playerColor;
        }

        function getRandomMove() {
            let emptyCells = [];
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    if (!board[x][y]) {
                        emptyCells.push({ x, y });
                    }
                }
            }
            return emptyCells[Math.floor(Math.random() * emptyCells.length)];
        }

        function getMediumMove() {
            // 简单的防守和进攻策略
            let move = findBestMove(1);
            if (move) return move;
            return getRandomMove();
        }

        function getBestMove() {
            // 使用 Alpha-Beta 剪枝的 Minimax 算法
            let bestScore = -Infinity;
            let move = null;
            let depth = 1; // 限制搜索深度

            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    if (!board[x][y]) {
                        board[x][y] = aiColor;
                        let score = minimax(board, depth - 1, -Infinity, Infinity, false);
                        board[x][y] = null;
                        if (score > bestScore) {
                            bestScore = score;
                            move = { x, y };
                        }
                    }
                }
            }
            return move || getRandomMove();
        }

        function minimax(board, depth, alpha, beta, isMaximizing) {
            if (depth === 0 || gameOver) {
                return evaluateBoard(board);
            }

            if (isMaximizing) {
                let maxEval = -Infinity;
                for (let x = 0; x < size; x++) {
                    for (let y = 0; y < size; y++) {
                        if (!board[x][y]) {
                            board[x][y] = aiColor;
                            let eval = minimax(board, depth - 1, alpha, beta, false);
                            board[x][y] = null;
                            maxEval = Math.max(maxEval, eval);
                            alpha = Math.max(alpha, eval);
                            if (beta <= alpha) break;
                        }
                    }
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (let x = 0; x < size; x++) {
                    for (let y = 0; y < size; y++) {
                        if (!board[x][y]) {
                            board[x][y] = playerColor;
                            let eval = minimax(board, depth - 1, alpha, beta, true);
                            board[x][y] = null;
                            minEval = Math.min(minEval, eval);
                            beta = Math.min(beta, eval);
                            if (beta <= alpha) break;
                        }
                    }
                }
                return minEval;
            }
        }

        function evaluateBoard(board) {
            // 简单的评分函数
            let aiScore = calculateScore(board, aiColor);
            let playerScore = calculateScore(board, playerColor);
            return aiScore - playerScore;
        }

        function calculateScore(board, color) {
            let score = 0;
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    if (board[x][y] === color) {
                        score += countSequences(x, y, color);
                    }
                }
            }
            return score;
        }

        function countSequences(x, y, color) {
            let directions = [
                { dx: 1, dy: 0 },
                { dx: 0, dy: 1 },
                { dx: 1, dy: 1 },
                { dx: 1, dy: -1 }
            ];
            let total = 0;
            for (let dir of directions) {
                let count = 1;
                let i = 1;
                while (true) {
                    let nx = x + dir.dx * i;
                    let ny = y + dir.dy * i;
                    if (nx < 0 || ny < 0 || nx >= size || ny >= size || board[nx][ny] !== color) break;
                    count++;
                    i++;
                }
                total += Math.pow(10, count);
            }
            return total;
        }

        function checkWin(x, y) {
            return checkDirection(x, y, 1, 0) || // 水平
                   checkDirection(x, y, 0, 1) || // 垂直
                   checkDirection(x, y, 1, 1) || // 斜对角 \
                   checkDirection(x, y, 1, -1);  // 斜对角 /
        }

        function checkDirection(x, y, dx, dy) {
            let color = board[x][y];
            let count = 1;
            for (let i = 1; i < 5; i++) {
                let nx = x + i * dx;
                let ny = y + i * dy;
                if (nx < 0 || ny < 0 || nx >= size || ny >= size || board[nx][ny] !== color) break;
                count++;
            }
            for (let i = 1; i < 5; i++) {
                let nx = x - i * dx;
                let ny = y - i * dy;
                if (nx < 0 || ny < 0 || nx >= size || ny >= size || board[nx][ny] !== color) break;
                count++;
            }
            return count >= 5;
        }

        function isBoardFull() {
            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    if (!board[x][y]) return false;
                }
            }
            return true;
        }

        // 初始化游戏
        startGame();
    </script>
</body>
</html>
